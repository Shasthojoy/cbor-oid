---
title: Concise Binary Object Representation (CBOR) Tags for ASN.1 Object Identifiers, and Omnibus Corrections and Techniques
abbrev: CBOR Tags for ASN.1 OIDs
docname: draft-bormann-cbor-tags-oid-03
date: 2016-06-16

stand_alone: true

ipr: trust200902
keyword: Internet-Draft
cat: std

pi: [toc, [tocdepth, 1], sortrefs, symrefs, compact, comments]

author:
  -
    ins: C. Bormann
    name: Carsten Bormann
    org: Universität Bremen TZI
    street: Postfach 330440
    city: Bremen
    code: D-28359
    country: Germany
    phone: +49-421-218-63921
    email: cabo@tzi.org
  -
    ins: S. Leonard
    name: Sean Leonard
    email: dev+ietf@seantek.com
    uri: http://www.penango.com/
    org: Penango, Inc.
    street:
      - 5900 Wilshire Boulevard
      - 21st Floor
    city: Los Angeles, CA
    code: 90036
    country: USA


normative:
  RFC2045:
  RFC3261:
  RFC5322:
  RFC5536:
  RFC5537:
  RFC7049:
  RFC7230:
  X.660:
    title: >
      Information technology —
      Procedures for the operation of object identifier registration authorities:
      General procedures and top arcs of the international object identifier tree
    author:
      org: International Telecommunications Union
    date: 2011-07
    seriesinfo:
      ITU-T: Recommendation X.660

  X.680:
    title: >
      Information technology — Abstract Syntax Notation One (ASN.1):
      Specification of basic notation
    author:
      org: International Telecommunications Union
    date: 2015-08
    seriesinfo:
      ITU-T: Recommendation X.680

  X.690:
    title: >
      Information technology — ASN.1 encoding rules:
      Specification of Basic Encoding Rules (BER), Canonical Encoding
      Rules (CER) and Distinguished Encoding Rules (DER)
    author:
      org: International Telecommunications Union
    date: 2015-08
    seriesinfo:
      ITU-T: Recommendation X.690

informative:
  RFC3030:
  RFC5280:
  CCITT.X208.1988: ASN1
  X.672:
    title: >
      Information technology — Open systems interconnection —
      Object identifier resolution system
    author:
      org: International Telecommunications Union
    date: 2010-08
    seriesinfo:
      ITU-T: Recommendation X.672
  X.681:
    title: >
      Information technology — Abstract Syntax Notation One (ASN.1):
      Information object specification
    author:
      org: International Telecommunications Union
    date: 2015-08
    seriesinfo:
      ITU-T: Recommendation X.681
  OID-INFO:
    target: http://www.oid-info.com/
    title: >
      OID Repository
    author:
      org: Orange SA
    date: 2016
  PKILCAKE:
    target: http://dl.acm.org/citation.cfm?id=2163593
    title: >
      PKI Layer Cake:
      New Collision Attacks Against the Global X.509 Infrastructure
    author:
      -
        name: Dan Kaminsky
        ins: D. Kaminsky
      -
        name: Meredith L. Patterson
        ins: M. L. Patterson
      -
        name: Len Sassaman
        ins: L. Sassaman
    date: 2010-01
    seriesinfo:
      FC: 2010
      Lecture Notes in Computer Science 6052: 289-303
      DOI:: 10.1007/978-3-642-14577-3_22
  DOUBLEDABBLE:
    author:
      - ins: S. Gao
      - ins: D. Al-Khalili
      - ins: N. Chabini
    date: 2012-06
    title: An improved BCD adder using 6-LUT FPGAs
    seriesinfo:
      IEEE: 10th International New Circuits and Systems Conference (NEWCAS 2012), pp. 13–16
      DOI:: 10.1109/NEWCAS.2012.6328944

--- abstract



The Concise Binary Object Representation (CBOR, RFC 7049) is a data
format whose design goals include the possibility of extremely small
code size, fairly small message size, and extensibility without the
need for version negotiation.

The present document makes use of this extensibility to define
CBOR tags «O» and «R» \[values TBD] for ASN.1 object identifiers.  It is intended
as the reference document for the IANA registration of the CBOR tags
so defined. This document also provides other corrections and improvements to CBOR.

--- middle

Introduction        {#intro}
============

The Concise Binary Object Representation (CBOR, {{RFC7049}}) provides
for the interchange of structured data without a requirement for a
pre-agreed schema.
RFC 7049 defines a basic set of data types, as well as a tagging
mechanism that enables extending the set of data types supported via
an IANA registry.

Many IETF protocols carry ASN.1 object identifiers, originally defined in
1988 {{-ASN1}} and most recently in 2008 {{X.680}}.  The ASN.1 Basic Encoding Rules
(BER, {{X.690}}) specify the binary encodings of both ASN.1 object identifiers
and relative object identifiers.
The contents of these encodings can be carried in a CBOR byte string.

This document defines two CBOR tags that cover the two kinds of
ASN.1 object identifiers encoded in this way.
It is intended as the reference document for the IANA registration of
the tags so defined.

During development of this Internet-Draft, a couple of deficiencies
and points of enhancement were noted. This document updates {{RFC7049}}
to handle binary Internet messages
natively, and provides certain techniques for efficiently
encoding sets in CBOR.

Terminology         {#terms}
------------

The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL
NOT", "SHOULD", "SHOULD NOT", "RECOMMENDED",  "NOT RECOMMENDED", "MAY", and
"OPTIONAL" in this document are to be interpreted as described in
RFC 2119 {{!RFC2119}}.

The terminology of RFC 7049 applies; in particular
the term "byte" is used in its now customary sense as a synonym for
"octet".

ASN.1 Object Identifiers {#oids}
========================

The International Object Identifier tree {{X.660}} is
a hierarchically managed space of
identifiers, each of which is uniquely represented as a sequence of
unsigned integers ("sub-identifiers")
{{X.680}}.
While these sequences can easily be represented in CBOR arrays of
unsigned integers, a more compact representation can often be achieved
by adopting the widely used representation of ASN.1 object identifiers
defined in BER; this representation may also be more amenable to
processing by other software making use of ASN.1 object identifiers.

BER represents the sequence of unsigned integers by concatenating
self-delimiting {{?RFC6256}} representations of each of the sub-identifiers
in sequence.

ASN.1 distinguishes absolute object identifiers (ASN.1 Type `OBJECT IDENTIFIER`),
which begin at a root arc ({{X.660}} Clause 3.5.21), from relative object
identifiers (ASN.1 Type `RELATIVE-OID`), which begin
relative to some object identifier known from context ({{X.680}}
Clause 3.8.63).
As a special optimization,
BER combines the first two integers in an absolute object identifier
into one numeric identifier by making use of the property of the
hierarchy that the first arc has only three integer values (0, 1, and 2),
and the second arcs under 0 and 1 are limited to the integer values between
0 and 39.  (The root arc `joint-iso-itu-t(2)` has
no such limitations on its second arc.)
If X and Y are the first two integers,
the single integer actually encoded is computed as:

> X * 40 + Y

The inverse transformation (again making use of the known ranges of X
and Y) is applied when decoding the ASN.1 object identifier.

Since the semantics of absolute and relative object identifiers
differ, this specification defines two tags:

Tag «O» (value TBD): tags a byte string as the ASN.1 BER encoding of an
absolute object identifier (simply "object identifier" or "OID").

Tag «R» (value TBD): tags a byte string as the ASN.1 BER encoding of a
relative object identifier (also "relative OID").

## Requirements on the byte string being tagged {#reqts}

A byte string tagged by «O» or «R» MUST be a syntactically valid BER
representation of an ASN.1 object identifier.  Specifically:

* its first byte, and any byte that follows a byte that has the most significant
  bit unset, MUST NOT be 0x80 (this requirement excludes expressing the
  sub-identifiers with anything but the shortest form)
* its last byte MUST NOT have the most significant bit set (this
  requirement excludes an incomplete final sub-identifier)

If either of these invalid conditions are encountered, they MUST be
treated as decoding errors. Comparing two OIDs or relative OIDs for
equality in a byte-for-byte fashion may not be safe before these checks
succeed on at least one of them (this includes the case where one of
them is a local constant); a process implementing an exclusion list
MUST check for decoding errors first.

{{X.680}} restricts RELATIVE-OID values to have at least
one sub-identifier (array element).
This specification permits
empty relative object identifiers; they may still be excluded by application semantics.

{{RFC7049}} permits byte strings to be indefinite-length,
with chunks divided at arbitrary byte boundaries.
This contrasts with text strings, where each chunk in an indefinite-length
text string is required be well-formed UTF-8 on its own: splitting the octets of
a UTF-8 character encoding between chunks is not allowed.

By analogy to this principle and to Clauses 8.9.1 and 8.20.1 of
{{X.690}}, the byte strings carrying the OIDs and relative OIDs are
also to be treated as indivisible units: They MUST be encoded in
definite-length form; indefinite-length form is treated as an encoding
error (and the same considerations as above apply).
(An added convenience is that CBOR encodings can
be searched through efficiently for specific OIDs or relative OIDs,
without initiating the decoding process.)

Examples {#examples}
========

In the following examples, we are using tag number 6 for «O» and tag
number 7 for «R».  See {{ianadis}}.

## Encoding of the SHA-256 OID

ASN.1 Value Notation\\
{ joint-iso-itu-t(2) country(16) us(840) organization(1) gov(101)\\
        csor(3) nistalgorithm(4) hashalgs(2) sha256(1) }

Dotted Decimal Notation (also XML Value Notation)\\
2.16.840.1.101.3.4.2.1


~~~~~~~~~~~
06                                # UNIVERSAL TAG 6
   09                             # 9 bytes, primitive
      60 86 48 01 65 03 04 02 01  # X.690 Clause 8.19
#      |   840  1  |  3  4  2  1    show component encoding
#   2.16         101
~~~~~~~~~~~
{: #fig-sha-ber title="SHA-256 OID in BER"}

~~~~~~~~~~~
C6                                # 0b110_00110: mt 6, tag 6
   49                             # 0b010_01001: mt 2, 9 bytes
      60 86 48 01 65 03 04 02 01  # X.690 Clause 8.19
~~~~~~~~~~~
{: #fig-sha-cbor title="SHA-256 OID in CBOR"}

## Encoding of a UUID OID

UUID\\
8b0d1a20-dcc5-11d9-bda9-0002a5d5c51b

ASN.1 Value Notation\\
{ joint-iso-itu-t(2) uuid(25)\\
  geomicaGPAS(184830721219540099336690027854602552603) }

Dotted Decimal Notation (also XML Value Notation)\\
2.25.184830721219540099336690027854602552603

~~~~~~~~~~~
06                                # UNIVERSAL TAG 6
   14                             # 20 bytes, primitive
      69 82 96 8D 8D 88 9B CC A8 C7 B3 BD D4 C0 80 AA AE D7 8A 1B
#      |                  184830721219540099336690027854602552603
#   2.25
~~~~~~~~~~~
{: #fig-uuid-ber title="UUID in an object identifier, in BER"}

~~~~~~~~~~~
C6                                # 0b110_00110: mt 6, tag 6
   54                             # 0b010_10100: mt 2, 20 bytes
      69 82 96 8D 8D 88 9B CC A8 C7 B3 BD D4 C0 80 AA AE D7 8A 1B
~~~~~~~~~~~
{: #fig-uuid-cbor title="UUID in an object identifier, in CBOR"}

## Encoding of a MIB Relative OID

Given some OID (e.g., `lowpanMib`, assumed to be `1.3.6.1.2.1.226` {{?RFC7388}}),
to which the following is added:

ASN.1 Value Notation (not suitable for diagnostic notation)\\
{ lowpanObjects(1) lowpanStats(1) lowpanOutTransmits(29) }

Dotted Decimal Notation (diagnostic notation; see Section 5)\\
.1.1.29

~~~~~~~~~~~
0D                                # UNIVERSAL TAG 13
   03                             # 3 bytes, primitive
      01 01 1D                    # X.690 Clause 8.20
#      1  1 29                      show component encoding
~~~~~~~~~~~
{: #fig-mib-ber title="MIB relative object identifier, in BER"}

~~~~~~~~~~~
C7                                # 0b110_00110: mt 6, tag 7
   43                             # 0b010_01001: mt 2 (bstr), 3 bytes
      01 01 1D                    # X.690 Clause 8.20
~~~~~~~~~~~
{: #fig-mib-cbor title="MIB relative object identifier, in CBOR"}

This relative OID saves seven bytes compared to the full OID encoding.

Discussion {#discussion}
==========

Staying close to the way ASN.1 object identifiers are encoded in ASN.1
BER makes back-and-forth translation easy.  As of today, ASN.1 object
identifiers are either used in dotted decimal form or BER form, so
there is an advantage in not inventing a third form.  Also,
expectations of the cost of encoding ASN.1 object identifiers are
based on BER; using a different encoding might not be aligned with
these expectations. If additional information about an OID is desired,
lookup services such as the <xref target="X.672">OID Resolution Service (ORS)</xref>
and the <xref target="OID-INFO">OID Repository</xref> are available.

This specification allocates two numbers out of the single-byte
tag space.  This use of code point space is justified by the wide use
of object identifiers in data interchange. For most common OIDs in use
(namely those whose contents encode to less than 24 bytes),
the CBOR encoding will match the efficiency of {{X.690}}.
(This preliminary conclusion is likely to generate some discussion,
see {{ianadis}}.)

Diagnostic Notation {#diagnostic}
============

Implementers will likely want to see OIDs and relative OIDs
in their "natural forms" (as sequences of decimal unsigned integers)
for diagnostic purposes. Accordingly, this section defines additional
syntactic elements that can be used in conjunction with the diagnostic
notation described in Section 6 of {{RFC7049}}.

An object identifier may be written in ASN.1 value notation (with
enclosing braces and secondary identifiers,
ObjectIdentifierValue of Clause 32.3 of {{X.680}}),
or in dotted decimal notation
with at least three arcs. Both examples are shown in Section 3.
The
surrounding tag notation is not to be used, because
the tag is implied. The ASN.1 value notation for OIDs does not
overlap with JSON object notation for CBOR maps, because at least
two arcs are required for a valid OID.

A relative object identifier may be written in dotted decimal notation
or in ASN.1 value notation, in both cases
prefixed with a dot as shown in Section 3.3. The surrounding
tag notation is not to be used, because the tag is implied.

The notation in this section may be employed in addition to the basic notation,
which would be a tagged binary string.

| RFC 7049 diagnostic notation | 6(h'2b0601') | 7(h'0601') |
| Dotted decimal notation      | 1.3.6.1      | .6.1       |
| ASN.1 value notation         | {1 3 6 1}    | .{6 1}     |
{: #tab-diagnostic title="Examples for extended diagnostic notation"}

OID Enumerations
============
This section provides
a roadmap to using OIDs as enumerated items.

CBOR does not have an ENUMERATED type like ASN.1 to identify
named values in a protocol element with three or more states
(Clause 20 and Clause G.2.3 of {{X.680}}).
ASN.1 ENUMERATED turns out to be superfluous because ASN.1
INTEGER values can get named (and have historically been used for finite,
multistate variables, such as version numbers),
while ASN.1 ENUMERATED types
can be defined to be extensible with the ellipsis lexical item.
Practically, the named integers are not serialized in the binary
encodings anyway; they merely serve as a semantic hints for designers
and debuggers.

CBOR expects that protocol designers will use
one of the basic major types for multistate
variables, assigning semantics to particular values
using higher-level schemas. The obvious choices
for the basic types are integers (particularly
unsigned integers) and UTF-8 strings. However,
these major types are not without drawbacks.

Integers are compact for small values, but have
a flat namespace so there are mis-assignment
and collision risks that can only be mitigated
with protocol-specific registries.
Arrays of integers are possible, but arrays require
more processing logic for equality comparisons,
and the JSON conversion is not intuitive when
the enumerated value serves as a key in a map.

UTF-8 strings are less compact when the strings
are supposed to resemble their semantics, and there are
normalization issues if the strings contain characters
beyond the ASCII range. UTF-8 strings also comprise
a flat namespace like integers unless the higher-level
schema employs delimiters
(which makes the string even larger). This section
provides a novel alternative in OIDs.

## Factors Favoring OID Enumerations

A protocol designer might choose OIDs or relative OIDs
for an enumerated item in view of the following observations:

1. OIDs and relative OIDs are relatively compact:
a relative OID
encoded according to this specification
occupies two bytes for a single arc with
primary integer values 0-127 (excluding the semantic tag «R»).
(In contrast, an unsigned integer requires one byte
for 0-23, two bytes for 24-255, and three bytes
for 256-65535.)

2. OIDs and relative OIDs (with base) are persistent
and globally unambiguous.

3. OIDs and relative OIDs have built-in semantics
for designers and debuggers. Specifically,
the advent of universal OID repositories such as
{{OID-INFO}} makes it easy for a designer
or debugger to pull up useful information
about the object of interest (Clause 3.5.10 of {{X.660}}).
This useful information (for humans) does not have to bleed
into the encoded representation (for machines).

4. OIDs and relative OIDs are always compared for
exact equality: no need to deal with case folding,
case sensitivity, or other normalization issues.
("Overlong" encodings are PROHIBITED; therefore
overlong encodings MUST be treated as coding errors.)

5. OIDs and relative OIDs have a built-in hierarchy,
so if implementers want to extend an enumeration
without assigning new values "horizontally", they
have the option of assigning new values "vertically",
possibly with more or less stringent assignment rules.

6. Because OIDs and relative OIDs (with base)
are part of the so-called International Object Identifier tree
{{X.660}}, any other protocol specification can reuse
the enumeration if the designers find it useful.

7. OIDs and relative OIDs have natural JSON
representations in the dotted decimal notations
prescribed in {{diagnostic}}. OIDs and relative
OIDs can be distinguished from each other
by the presence or absence of the leading dot ".".
As the resulting JSON string is entirely numeric
in the ASCII range, case and normalization are irrelevant to the comparison.
(An object identifier also has a semantic string
reprsentation in the form of an OID-IRI {{X.680}},
for those who really want that type of thing.)

8. OIDs and relative OIDs are human language-neutral.
A protocol designer working in US-English might
name an enumerated value "sig" for "signature", but "sig"
could also stand for "significand", "signal", or
"special interest group".
In Swedish and Norwegian, "sig" is a pronoun
that means "himself, herself, itself, one, them",
etc.&emdash;an entirely different meaning.

## Factors Favoring Integer Enumerations

A protocol designer might choose integers
for an enumerated item in view of the following observations:

1. The CBOR encoding of unsigned integers 0-23 is the most
compact, occupying exactly one byte (excluding any semantic tags).

2. A protocol designer may wish to prohibit extensibility
as a matter of course. Integers comprise a single flat namespace:
there is no hierarchy.

3. If greater range is desired while sticking to one byte,
a protocol designer may double the range of possible values
by allowing negative integers -24 - -1.
However, enumerating values using negative integers may have
unintended side-effects, because some programming environments
(e.g., C/C++) make implementation-defined assumptions about
the number of bits needed for an enumerated type.

## Factors Favoring UTF-8 String Enumerations

A protocol designer might choose UTF-8 strings
for an enumerated item in view of the following observations:

1. A specification can practically limit the content of UTF-8 strings
   to the ASCII range (or narrower), obviating normalization problems.

2. UTF-8 strings are easier to read on-the-wire for humans.

3. UTF-8 strings can contain arbitrary textual identifiers, which
   can be hierarchial, e.g., URIs.

## OID Enumeration Example

(TODO: example of enumerated thing in CBOR, diagnostic notation, JSON.)

OID Arrays, Maps, and Associations
============
A common use of OIDs in ASN.1 is to identify the kind of data
in an open type (Clause 3.8.57 of {{X.680}}), using
information object classes {{X.681}}. CBOR
is schema-neutral, and (although not fully discussed
in {{RFC7049}}) semantic tagging was originally
intended to identify items
in a global, context-free way
(i.e., where a specification would not repurpose
a tag with different semantics than its IANA
registration). Therefore,
using OIDs to identify contextual data
in a similar fashion to {{X.681}} is RECOMMENDED.

«O» and «R» can tag CBOR arrays and maps.

When the «O» or «R» tag is applied to an array, it means
that the data is an arry of OIDs or relative OIDs, respectively.

When the «O» or «R» tag is applied to a map, it means that
the keys are all OIDs, or all relative OIDs, respectively.
The values in the map are not considered specially tagged.

## Switching OID and Relative OID

If an individual item in a «O» or «R» tagged array, or
an individual key in a «O» or «R» tagged map, is tagged
with the opposite tag («R» or «O») of the array or map itself,
that tag cancels and replaces the outer tag for that item.
Like tags MUST NOT be used on such individual items.
For example, if «R» is the outer tag on an array
and «O» is the inner tag
on a binary string, semantically the inner item is
treated as a regular OID, not as a relative OID.

The purpose is to create more compact and flexible identifier spaces,
especially when object identifiers are used as
enumerated items. Examples:

«R» outside, «O» inside: An implementation that strives for a compact representation,
does not have to emit base OID arcs repeatedly for each item.
At the same time, if a private organization or standards body
separate from the specification needs to identify something
that the specification maintainers disagree with,
the separate body does not need to request registration
of an identifier under a controlled arc (i.e., the base arc of the relative OIDs).

«O» outside, «R» inside: A collection of OIDs is supposed
to be open to all-comers, but a certain set of OIDs issued
under a particular arc is foreseeable for the majority of implementations.
For example, an OID protocol slot may identify cryptographic
algorithms: anyone can write (and has written) an algorithm
with an arbitrary OID. However, the protocol slot designer may
wish to privilege certain algorithms (and therefore OIDs)
that are well-known in that field of use.

## Tag Stacking

CBOR permits tag stacking (tagging a tagged item),
although this technique has not
been used much yet. This specification anticipates that OIDs
and relative OIDs will be associated with values with
uniform semantics. This section provides specific semantics
when tags are "stacked", that is, a CBOR item
starts with tag «O» or «R», followed by one or more arbitrary tags
("subsequent tags"),
followed by a map or array.

### Map

The overall gist is that the first tag applies to the keys in a map;
the subsequent tags apply to the values in a map.

When «O» or «R» is the first tag
in a stack of tags, followed by a map:
o The «O» or «R» tag indicates that the keys of the map are
  OIDs or relative OIDs.
	(Discuss the byte strings.)
o The subsequent tags uniformly apply to all of the values.

For example, if tag 32 (URL) is the subsequent tag, then
all values in the map are treated semantically as if tag 32 is
applied to them individually.

It is possible that individual values can be tagged. Semantically,
these tags cumulate with the outer subsequent tags; inner value tags
do not cancel or replace the outer tags.

### Array

The overall gist is that the first tag applies
to the ordered "keys" in the array (even-numbered items,
assuming that the index starts at 0);
the subsequent tags apply to the ordered "values"
in the array (odd-numbered items). This tagging technique
creates an ordered associative array.
\[\[NB:
Some call this the FORTRAN approach. need to cite\]\]

When «O» or «R» is the first tag in a stack of tags,
followed by an array:
o The «O» or «R» tag indicates that alternating items,
  starting with the first item, are OIDs or relative OIDs.
	Said items MUST be byte strings containing OIDs or relative OIDs.
o The subsequent tags uniformly apply to the alternating items,
  starting with the second item.
o The array MUST have an even number of items; an array
  that has an odd number of items is a coding error.

To create an ordered associative array wherein the values
(even elements) are arbitrarily tagged,
stack tag 55799, self-describe CBOR (Section 2.4.5
of {{RFC7049}}), after the «O» or «R» tag.
Tag 55799 imparts no special semantics, so it is
an effective placeholder.
(This sequence is mainly provided for completeness:
it is a more compact alternative to an array of duple-arrays that
each contain
an OID or relative OID, and an arbitrary value.)

Applications and Examples of OIDs
============

(TODO: show OID arrays, OID maps, OID maps to
OID-defined types, example of X.500 distinguished name
realized as CBOR sequence.)

Binary Internet Messages and MIME Entities
============

Section 2.4.4.3 of {{RFC7049}} assigns tag 36
to "MIME messages (including all headers)" {{RFC2045}},
and prescribes UTF-8 strings, without further elaboration.
Actually MIME encircles several different formats,
and is not limited to UTF-8 strings. This section updates
tag 36.

## CBOR Byte String and Binary MIME

Tag 36 is to be used with byte strings. When the tagged
item is a byte string, any octet can be used in the content.
Arbitrary octets are supported by {{RFC2045}}
and can be supported in protocols such as SMTP
using BINARYMIME {{RFC3030}}.

A conforming implementation that purports to process
tag 36-tagged items, MUST accept byte strings
as well as UTF-8 strings. Byte strings, rather than UTF-8
strings, SHOULD be considered the default.
(While binary Content-Transfer-Encoding is not particularly
common as of this writing, 8-bit encoding is, and it is foreseeable
that many 8-bit encoded messages will still have charsets
other than UTF-8.)

## Internet Messages, MIME Messages, and MIME Entities

Definitions: "MIME message" is not explicitly defined
in {{RFC2045}}, but a careful read suggests that
a MIME message is: "either a
(complete or "top-level") RFC 822 message being transferred on a
network, or a message encapsulated in a body of type "message/rfc822"
or "message/partial"," that also contains MIME header fields,
namely, MIME-Version field, which MUST be present
(Section 4 of {{RFC2045}}. Other MIME header fields
such as Content-Type and Content-Transfer-Encoding
are assumed to be their {{RFC2045}} default values,
if not present in the data.

When the contents have a From field (a type of "originator address field")
and a Date field (the lone "origination date field")
(Section 3.6 of {{RFC5322}}),
the item is concluded to have a Content-Type of message/rfc822
or message/global, as appropriate, except as otherwise
specified in this section.

(TBD: Do we need a separate tag for a MIME entity?)
(Alternate proposal: When the tagged data does not
include a MIME-Version field or other
fields required by RFC822 (5322) (e.g., no From field),
it is presumed to be a MIME entity, rather than
a MIME message. Therefore, it has no top-level content-type:
instead it is simply a "MIME entity", consisting of
one element, whose Content-Type is the content of the
Content-Type header field, if present,
or the {{RFC2045}} default of "text/plain; charset=us-ascii",
if absent. Content-Transfer-Encoding
SHALL be assumed to be 8bit when the CBOR item
is a UTF-8 string, and SHALL be assumed to be binary
when the CBOR item is a byte string. (Or should
all be considered CTE: binary?) And, when the tagged
data has RFC822 required fields but no MIME-Version,
shall we assume it's a MIME entity, or shall we assume
it's an Internet message that does not conform to MIME?)

Content that has no headers whatsoever is valid, and
implementations that process tag 36 MUST permit this case:
in such a case, the data starts with CRLF CRLF,
followed by the body. In such a case, the content
is assumed to be a MIME entity of Content-Type
"text/plain; charset=us-ascii", and not an
RFC822 (RFC5322) Internet message. (TBD: Confirm.)

## Netnews, HTTP, and SIP Messages

Other message types that are MIME-related
are message/news, message/http, and message/sip.

{{RFC5537}} specifies that message/news is deprecated
(marked as obsolete) and that message/rfc822
SHOULD be used in its place; presumably this
also extends to message/global over time.
Netnews Article Format {{RFC5536}} is a strict
subset of Internet Message Format; it can be
detected by the presence of the six mandatory
header fields: Date, From, Message-ID, Newsgroups,
Path, and Subject. (Newsgroups and Path fields
are specific to Netnews.)

message/http {{RFC7230}} is the media type
for HTTP requests and responses. It can be detected
by analyzing the first line of the body, which is
an HTTP Start Line (Section 3.1 of {{RFC7230}}):
it does not conform to the syntax
of an Internet Message Format header field.
The optional parameter "msgtype" can be inferred
from the Start Line. Implementers need to be
aware that the default character encoding for
message/http is ISO-8859-1, not UTF-8. Therefore,
implementations SHOULD NOT encode HTTP messages
with CBOR UTF-8 strings.

Similarly, message/sip {{RFC3261}} is the media type of
SIP request and response messages. It can be detected
by analyzing the first line of the body, which is
a SIP start-line (Section 7.1 of {{RFC3261}}):
it does not conform to the syntax of an Internet Message Format
header field. The optional parameter can be inferred
from the start-line.

## Other Messages

The CBOR binary or UTF-8 string MAY contain other
types of messages. An implementation MAY send such a
message as a MIME entity with the Content-Type
field appropriately set, or alternatively, MAY
send the message at the top-level directly.
However, if a purported message type is ambiguous with
a message/rfc822 (or message/global)
message, a receiver SHALL treat the message
as message/rfc822 (or message/global).
If a purported message type is ambiguous with
a MIME entity (and unambiguously not message/rfc822
or message/global), a receiver SHALL treat
the message as a MIME entity.

Applications and Examples of Messages and Entities
============

Tag 36 is the RECOMMEDED way to convey data with
MIME-related metadata, including messages
(which may or may not actually be MIME-enabled) and MIME entities.

Example 1: A legacy RFC822 message is encoded as
a UTF-8 string or byte string with tag 36. The contents
have From, To, Date, and Subject header fields, two CRLFs,
and a single line "Hello World!", terminated with a CRLF.

Example 2a: A {{RFC5280}} certificate is encoded as
a byte string with tag 36. The contents are
comprised of "Content-Type: application/pkix-cert",
two CRLFs, and the DER encoding of the certificate.
(The "Content-Transfer-Encoding: binary" header is
not necessary.)

Example 2b: A {{RFC5280}} certificate is encoded
as a UTF-8 string or byte string with tag 36. The contents
are comprised of "Content-Type: application/pkix-cert",
a CRLF, "Content-Transfer-Encoding: base64",
two CRLFs, and the base64 encoding of the DER
encoding of the certificate, conforming to Section 6.8
of {{RFC2045}}. In particular, base64 lines are limted
to 76 characters, separated by CRLF, and the final line
is supposed to end with CRLF. Needless to say, this
is not nearly as efficient as Example 2a.

X.690 Series Tags
============

\[\[NB: Carsten probably won't like this. Plan on removing this section. LOL\]\]

It is foreseeable that CBOR applications will need
to send and receive ASN.1 data, for example, for legacy
or security applications. While a native representation
in CBOR is preferred, preserving the data in an ASN.1
encoding may be necessary, for example, to preserve
cryptographic verification. A tag «X» is allocated
for this purpose.

When the tagged item is a byte string, the
byte string contents are encoded according to {{X.690}},
i.e., BER, CER, or DER. CBOR implementations
are not required to validate conformance of the contained
data to {{X.690}}.

When the tagged item is an array with 3 items:
1. The first item SHALL be an OID (with tag «O» omitted;
it SHALL NOT be a relative OID),
indicating the ASN.1 module containing the type of the PDU.

2. The second item SHALL be a UTF-8 string indicating
the ASN.1 value's <spanx style="emph">type reference name</spanx>
(Clause 3.8.88 of {{X.680}})
conforming to the <spanx style="verb">typereference</spanx> production
(Clause 12.2 of {{X.680}}).

3. The third item SHALL be a byte string,
whose contents are encoded per the prior paragraph.

(TBD: Use of tagged UTF-8 string is reserved for ASN.1
textual formats such as XER and ASN.1 value notation?
Probably not necessary. Just omit.)

Implementation note: DER-encoded items are always definite-length,
so there is very little reason to use CBOR byte string
indefinite encoding when encoding such DER-encoded items.

Example: A {{RFC5280}} certificate can be encoded as a byte string with tag «X»,
or as an array with tag «X», with three elements:
a byte string containing the BER encoding of 1.3.6.1.5.5.7.0.18,
a UTF-8 string "Certificate", and
a byte string containing the DER encoding of the certificate.

Regular Expression Clarification
============

(TODO: better specify conformance to
actual regular expression standards with tag 35.
PCRE and JavaScript/ECMAScript regular expressions are very different;
{{RFC7049}} is not specific enough about this.)

Set and Multiset Technique
============
CBOR has no native type for a set, which is an arbitrary
unordered collection of items. The following technique is
RECOMMENDED to express set and multiset semantics concisely
in native CBOR data.

In computer science, a <spanx style="emph">set</spanx>
is a collection of distinct items; there is no ordering
to the items. Thus, implementations can optimize set storage
in many ways that are not available with ordered elements in arrays.
Sets can be stored in hashtables, bit fields, trees, or other
abstract data types.

In computer science, a <spanx style="emph">multiset</spanx>
allows multiple instances of a set's elements.
Put another way, each distinct item has a cardinality property
indicating the number of these items in the multiset.

To store items in a set or multiset, it is RECOMMENDED
to store the CBOR items as keys in a map; the values
SHALL all be positive integers (major type 0, value/additional
information greater than or equal to 1). In the special
case of a set, the values SHALL be the integer 1.
This technique has no special tag associated with it.
As with
arrays that schemas classify as "records" (i.e.,
arrays with positionally defined elements), schemas are
likewise free to classify maps as sets in particular
instances.

Fruits Basket Example
============

Consider a basket of fruits. The basket can contain
any number of fruits; each fruit of the same species is
considered identical. This basket has two apples,
four bananas, six pears, and one pineapple:

~~~~~~~~~~~
{"apple": 2, "banana": 4, "pear": 6, "pineapple": 1}
~~~~~~~~~~~
{: #fig-fruits-basket-cbor-diag title="Fruits Basket in CBOR Diagnostic Notation"}

~~~~~~~~~~~
A4                       # map(4)
   65                    # text(5)
      6170706C65         # "apple"
   02                    # unsigned(2)
   66                    # text(6)
      62616E616E61       # "banana"
   04                    # unsigned(4)
   64                    # text(4)
      70656172           # "pear"
   06                    # unsigned(6)
   69                    # text(9)
      70696E656170706C65 # "pineapple"
   01                    # unsigned(1)
~~~~~~~~~~~
{: #fig-fruits-basket-cbor title="Fruits Basket in CBOR (33 bytes)"}


\[\[TODO: Consider a Merkle Tree example: set of sets of sets of sets of things. ???\]\]

IANA Considerations {#iana}
============

(This section to be edited by the RFC editor.)

## CBOR Tags

IANA is requested to assign the CBOR tags in {{tab-tag-values}}, with the
present document as the specification reference.

| Tag    | Data Item   | Semantics                                           |
| 6«TBD» | byte string | ASN.1 object identifier (absolute, in BER encoding) |
| 7«TBD» | byte string | ASN.1 object identifier (relative, in BER encoding) |
{: #tab-tag-values title="Values for Tags" cols="l 11eml r"}


## Discussion {#ianadis}

(This subsection to be removed by the RFC editor.)

The space for single-byte tags in CBOR (0..23) is severely limited.
It is not clear that the benefits of encoding OIDs/relative OIDs with
one less byte per instance outweigh the consumption of two values in
this code point space.

Procedurally, this space is also reserved for standards action.

An alternative would be to go for the specification required space,
e.g. tag number 40 for «O» and tag number 41 for «R».  As an example this would change
{{fig-sha-cbor}} into:

~~~~~~~~~~~
d8 28                            # tag(40)
   49                            # bytes(9)
      60 86 48 01 65 03 04 02 01 #
~~~~~~~~~~~
{: #fig-sha-cbor1 title="SHA-256 OID in cbor (using specification required tag)"}

## Pre-Existing Tags

(TODO: complete.)
IANA is requested to modify the registrations for the following CBOR tags:

Tag 36.

## New Tags

(TODO: complete.)

Security Considerations
============

The security considerations of RFC 7049 apply.

The encodings in Clauses 8.19 and 8.20 of {{X.690}} are extremely compact and unambiguous,
but MUST be followed precisely to avoid security pitfalls.
In particular, the requirements set out in {{reqts}} of this document need to be
followed; otherwise, an attacker may be able to subvert a checking
process by submitting alternative representations that are later taken
as the original (or even something else entirely) by another decoder
supposed to be protected by the checking process.

OIDs and relative OIDs can always be treated as opaque byte strings.
Actually understanding the structure that was used for generating them
is not necessary, and, except for checking the structure requirements,
it is strongly NOT RECOMMENDED to perform any
processing of this kind (e.g., converting into dotted notation and
back) unless absolutely necessary.
If the OIDs are translated into other representations, the usual
security considerations for non-trivial representation conversions
apply; the integers of the sub-identifiers need to be handled as
unlimited-range integers (cf. {{fig-uuid-cbor}}).

Conversions Between BER and Dotted Decimal Notation
------------

{{PKILCAKE}} uncovers exploit vectors for the illegal values above,
as well as for cases in which conversion to or from the dotted decimal notation
goes awry. Neither {{X.660}} nor {{X.680}} place an upper bound on the
range of unsigned integer values for an arc; the integers are arbitrarily valued.
An implementation SHOULD NOT attempt to convert each component using a
fixed-size accumulator, as an attacker will certainly be able to
cause the accumulator to overflow. Compact and efficient techniques
for such conversions, such as the double dabble algorithm {{DOUBLEDABBLE}}
are well-known in the art; their application to this field is left
as an exercise to the reader.

--- back


<!--  LocalWords:  CBOR extensibility IANA uint sint IEEE endian IETF
 -->
<!--  LocalWords:  signedness endianness ASN BER encodings OIDs OID
 -->
<!--  LocalWords:  Implementers
 -->
