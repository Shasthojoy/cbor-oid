---
title: Concise Binary Object Representation (CBOR) Tags for ASN.1 Object Identifiers
abbrev: CBOR tags for ASN.1 Object IDs
docname: draft-bormann-cbor-tags-oid-00-pre
date: 2014-10-23

stand_alone: true

ipr: trust200902
keyword: Internet-Draft
cat: info

pi: [toc, [tocdepth, 1], sortrefs, symrefs, compact, comments]

author:
  -
    ins: C. Bormann
    name: Carsten Bormann
    org: Universität Bremen TZI
    street: Postfach 330440
    city: Bremen
    code: D-28359
    country: Germany
    phone: +49-421-218-63921
    email: cabo@tzi.org
  -
    ins: S. Leonard
    name: Sean Leonard
    email: dev+ietf@seantek.com
    uri: http://www.penango.com/
    org: Penango, Inc.
    street:
      - 5900 Wilshire Boulevard
      - 21st Floor
    city: Los Angeles, CA
    code: 90036
    country: USA


normative:
  RFC7049:
  X.660:
    title: >
      Information technology —
      Procedures for the operation of object identifier registration authorities:
      General procedures and top arcs of the international object identifier tree
    author:
      org: International Telecommunications Union
    date: 2011-07
    seriesinfo:
      ITU-T: Recommendation X.660

  X.680:
    title: >
      Information technology — Abstract Syntax Notation One (ASN.1):
      Specification of basic notation
    author:
      org: International Telecommunications Union
    date: 2008-11
    seriesinfo:
      ITU-T: Recommendation X.680

  X.690:
    title: >
      Information technology — ASN.1 encoding rules:
      Specification of Basic Encoding Rules (BER), Canonical Encoding
      Rules (CER) and Distinguished Encoding Rules (DER)
    author:
      org: International Telecommunications Union
    date: 2008-11
    seriesinfo:
      ITU-T: Recommendation X.690

informative:
  CCITT.X208.1988: ASN1
  X.672:
    title: >
      Information technology — Open systems interconnection —
      Object identifier resolution system
    author:
      org: International Telecommunications Union
    date: 2010-08
    seriesinfo:
      ITU-T: Recommendation X.672
  OIDINFO:
    target: http://www.oid-info.com/
    title: >
      OID Repository
    author:
      org: Orange SA
    date: 2014
  PKILCAKE:
    target: http://dl.acm.org/citation.cfm?id=2163593
    title: >
      PKI Layer Cake:
      New Collision Attacks Against the Global X.509 Infrastructure
    author:
      -
        name: Dan Kaminsky
        ins: D. Kaminsky
      -
        name: Meredith L. Patterson
        ins: M. L. Patterson
      -
        name: Len Sassaman
        ins: L. Sassaman
    date: 2010-01
    seriesinfo:
      FC: 2010
      Lecture Notes in Computer Science 6052: 289-303
    annotation: doi:10.1007/978-3-642-14577-3_22

--- abstract



The Concise Binary Object Representation (CBOR, RFC 7049) is a data
format whose design goals include the possibility of extremely small
code size, fairly small message size, and extensibility without the
need for version negotiation.

The present document makes use of this extensibility to define
CBOR tags «O» and «R» \[values TBD] for ASN.1 object identifiers.  It is intended
as the reference document for the IANA registration of the CBOR tags
so defined.

--- middle

Introduction        {#intro}
============

The Concise Binary Object Representation (CBOR, {{RFC7049}}) provides
for the interchange of structured data without a requirement for a
pre-agreed schema.
RFC 7049 defines a basic set of data types, as well as a tagging
mechanism that enables extending the set of data types supported via
an IANA registry.

Many IETF protocols carry ASN.1 object identifiers, originally defined in
1988 {{-ASN1}} and most recently in 2008 {{X.680}}.  The ASN.1 Basic Encoding Rules
(BER, {{X.690}}) specifies the binary encodings of both ASN.1 object identifiers
and relative object identifiers.
The contents of these encodings can be carried in a CBOR byte string.

This document defines two CBOR tags that cover the two kinds of
ASN.1 object identifiers encoded in this way.
It is intended as the reference document for the IANA registration of
the tags so defined.

Terminology         {#terms}
------------

<!--
The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL
NOT", "SHOULD", "SHOULD NOT", "RECOMMENDED",  "MAY", and
"OPTIONAL" in this document are to be interpreted as described in
RFC 2119 {{ !RFC2119}}.
 -->

The term "byte" is used in its now customary sense as a synonym for
"octet".

ASN.1 Object Identifiers {#oids}
========================

The International Object Identifier tree {{X.660}} is
a hierarchically managed space of
identifiers, each of which is uniquely represented as a sequence of unsigned integers
{{X.680}}.
While these sequences can easily be represented in CBOR arrays of
unsigned integers, a more compact representation can often be achieved
by adopting the widely used representation of ASN.1 object identifiers
defined in BER.

BER represents the sequence of unsigned integers by concatenating
self-delimiting {{?RFC6256}} representations of each of these integers
in sequence.

ASN.1 distinguishes absolute object identifiers (ASN.1 Type `OBJECT IDENTIFIER`),
which begin at a root arc ({{X.660}} Clause 3.5.21), from relative object
identifiers (ASN.1 Type `RELATIVE-OID`), which begin
relative to some known object identifier ({{X.680}} Clause 3.8.63).  As
a special optimization,
BER combines the first two integers in an absolute object identifier
into one numeric identifier by making use of the property of the
hierarchy that the first arc has only three integer values (0, 1, and 2),
and the second arcs under 0 and 1 are limited to the integer values between
0 and 39.  (The root arc `joint-iso-itu-t(2)` has
no such limitations on its second arc.)
If X and Y are the first two integers,
the single integer actually encoded is computed as:

> X * 40 + Y

The inverse transformation (again making use of the known ranges of X
and Y) is applied when decoding the ASN.1 object identifier.

Since the semantics of absolute and relative object identifiers
differ, this specification defines two tags:

Tag «O» (value TBD): tags a byte string as the ASN.1 BER encoding of an
absolute object identifier (simply "object identifier" or "OID").

Tag «R» (value TBD): tags a byte string as the ASN.1 BER encoding of a
relative object identifier (also "relative OID").


Examples {#examples}
========

In the following examples, we are using tag number 6 for «O» and tag
number 7 for «O».  See {{ianadis}}.

## Encoding of the SHA-256 OID

ASN.1 Value Notation  
{ joint-iso-itu-t(2) country(16) us(840) organization(1) gov(101)  
        csor(3) nistalgorithm(4) hashalgs(2) sha256(1) }

Dotted Decimal Notation (also XML Value Notation)\\
2.16.840.1.101.3.4.2.1


~~~~~~~~~~~
06                                # UNIVERSAL TAG 6
   09                             # 9 bytes, primitive
      60 86 48 01 65 03 04 02 01  # X.690 Clause 8.19
#      |   840  1  |  3  4  2  1    show component encoding
#   2.16         101
~~~~~~~~~~~
{: #fig-sha-ber title="SHA-256 OID in BER"}

~~~~~~~~~~~
C6                                # 0b110_00110: mt 6, tag 6
   49                             # 0b010_01001: mt 2, 9 bytes
      60 86 48 01 65 03 04 02 01  # X.690 Clause 8.19
~~~~~~~~~~~
{: #fig-sha-cbor title="SHA-256 OID in CBOR"}

## Encoding of a UUID OID

UUID\\
8b0d1a20-dcc5-11d9-bda9-0002a5d5c51b

ASN.1 Value Notation\\
{ joint-iso-itu-t(2) uuid(25)\\
  geomicaGPAS(2957291539512641589387040445673640841648) }

Dotted Decimal Notation (also XML Value Notation)\\
2.25.2957291539512641589387040445673640841648

BER

~~~~~~~~~~~
06                                # UNIVERSAL TAG 6
   14                             # 20 bytes, primitive
      69 A2 E1 D1 D1 83 B9 C5 88 F6 B7 DA C8 80 85 A5 EA F1 A3 30
#      |                 2957291539512641589387040445673640841648
#   2.25
~~~~~~~~~~~

CBOR

~~~~~~~~~~~
C6                                # 0b110_00110: mt 6, tag 6
   54                             # 0b010_10100: mt 2, 20 bytes
      69 A2 E1 D1 D1 83 B9 C5 88 F6 B7 DA C8 80 85 A5 EA F1 A3 30`
~~~~~~~~~~~

## Encoding of a MIB Relative OID

Given some OID (e.g., `lowpanMib`, assumed to be `1.3.6.1.2.1.7001`),
to which the following is added:

ASN.1 Value Notation (not suitable for diagnostic notation)\\
{ lowpanObjects(1) lowpanStats(1) lowpanOutTransmits(29) }

Dotted Decimal Notation (diagnostic notation; see Section 5)\\
.1.1.29

BER

~~~~~~~~~~~
0D                                # UNIVERSAL TAG 13
   03                             # 3 bytes, primitive
      01 01 1D                    # X.690 Clause 8.20
#      1  1 29                      show component encoding
~~~~~~~~~~~

CBOR

~~~~~~~~~~~
C7                                # 0b110_00110: mt 6, tag 7
   43                             # 0b010_01001: mt 2 (bstr), 3 bytes
      01 01 1D                    # X.690 Clause 8.20
~~~~~~~~~~~

This relative OID saves seven bytes compared to the full OID encoding.

Discussion {#discussion}
==========

Staying close to the way ASN.1 object identifiers are encoded in ASN.1
BER makes back-and-forth translation easy.  As of today, ASN.1 object
identifiers are either used in dotted decimal form or BER form, so
there is an advantage in not inventing a third form.  Also,
expectations of the cost of encoding ASN.1 object identifiers are
based on BER; using a different encoding might not be aligned with
these expectations. If additional information about an OID is desired,
lookup services such as the OID Resolution Service (ORS, {{X.672}})
and the OID Repository (oid-info.com, {{OIDINFO}}) are available.

This specification allocates two numbers out of the single-byte
tag space.  This use of code point space is justified by the wide use
of object identifiers in data interchange. For most common OIDs in use
(namely those whose contents encode to less than 24 bytes),
the CBOR encoding will match the efficiency of {{X.690}}.

{{RFC7049}} permits byte strings to be indefinite-length,
with chunks divided at arbitrary byte boundaries.
In contrast, each definite-length text string chunk in an indefinite-length
text string MUST be well-formed UTF-8: splitting the octets of
a UTF-8 character encoding is not allowed. By analogy to this principle
and to Clauses 8.9.1 and 8.20.1 of {{X.690}},
OIDs and relative OIDs are to be treated as indivisible units. They MUST be
encoded in definite-length form. (An added convenience is that CBOR
encodings can be searched through efficiently for specific OIDs or
relative OIDs, without initiating the decoding process.)

Diagnostic Notation
============

Implementers will likely want to see OIDs and relative OIDs
in their "natural forms" (as sequences of unsigned integers)
for diagnostic purposes. Accordingly, this section defines additional
syntactic elements that can be used in conjunction with the diagnostic
notation described in Section 6 of {{RFC7049}}.

An object identifier may be written in ASN.1 value notation (with
enclosing braces and secondary identifiers), or in dotted decimal notation
with at least three arcs. Both examples are shown in Section 3.
The
surrounding tag notation is optional. The ASN.1 value notation for OIDs does not
overlap with JSON object notation for CBOR maps, because at least
two arcs are required for a valid OID.

A relative object identifier may be written in dotted decimal notation only,
prefixed with a dot as shown in Section 3.3. The surrounding
tag notation is optional.
ASN.1 value notation is not suitable for the diagnostic notation
of relative OIDs because
knowledge of the base OID cannot be determined from the encoding alone;
such knowledge requires a protocol on top of CBOR.

The notation in this section may be employed in addition to the basic notation,
which would be a tagged binary string.

| RFC 7049 diagnostic notation | 6(h'2b030601') | 7(h'0601') |
| Dotted decimal notation      | 1.3.6.1        | .6.1       |
| ASN.1 value notation         | {1 3 6 1}      | --N/A--    |
{: #tab-diagnostic title="Examples for extended diagnostic notation"}

IANA Considerations {#iana}
============

(This section to be edited by the RFC editor.)

IANA is requested to assign the CBOR tags in {{tab-tag-values}}, with the
present document as the specification reference.

| Tag    | Data Item   | Semantics                                           |
| 6«TBD» | byte string | ASN.1 object identifier (absolute, in BER encoding) |
| 7«TBD» | byte string | ASN.1 object identifier (relative, in BER encoding) |
{: #tab-tag-values title="Values for Tags" cols="l 11eml r"}


## Discussion {#ianadis}

(This subsection to be removed by the RFC editor.)

The space for single-byte tags in CBOR (0..23) is severely limited.
It is not clear that the benefits of encoding OIDs/relative OIDs with
one less byte per instance outweigh the consumption of two values in
this code point space.

Procedurally, this space is also reserved for standards action.

An alternative would be to go for the specification required space,
e.g. tag number 40 for «O» and tag number 41 for «O».  As an example this would change
{{fig-sha-cbor}} into:

~~~~~~~~~~~
d8 28                            # tag(40)
   49                            # bytes(9)
      60 86 48 01 65 03 04 02 01 #
~~~~~~~~~~~
{: #fig-sha-cbor1 title="SHA-256 OID in cbor (using specification required tag)"}


Security Considerations
============

The security considerations of RFC 7049 apply.

The encodings in Clauses 8.19 and 8.20 of {{X.690}} are extremely compact and unambiguous,
but MUST be followed precisely to avoid security pitfalls. In particular,
the byte 0x80 SHALL NOT appear in the byte string, because otherwise
an arc's integer value would not be encoded in the fewest possible octets.
Furthermore, the last byte SHALL NOT have its high-order bit (0b10000000)
set; such a byte implies that the arc's integer value
has been truncated.
If either of these illegal values are encountered, they MUST be treated
as decoding errors. Comparing two OIDs or relative OIDs
can be done byte-for-byte only after decoding succeeds.

OIDs and relative OIDs can always be treated as opaque byte strings.
Actually understanding the structure that was used for generating them
is not necessary, and it is strongly RECOMMENDED not to try.
If the OIDs are translated into other representations, the usual
security considerations for non-trivial representation conversions apply.

Conversions Between BER and Dotted Decimal Notation
------------

{{PKILCAKE}} uncovers exploit vectors for the illegal values above,
as well as for cases in which conversion to or from the dotted decimal notation
goes awry. Neither {{X.660}} nor {{X.680}} place an upper bound on the
range of unsigned integer values for an arc; the integers are abitrarily valued.
An implementation SHOULD NOT attempt to convert each component using a
fixed-size accumulator, as an attacker will certainly be able to
cause the accumulator to overflow. Compact and efficient techniques
for such conversions, such as the double dabble algorithm \[\[TODO: CITE\]\],
are well-known in the art; their application to this field is left
as an exercise to the reader.

--- back


<!--  LocalWords:  CBOR extensibility IANA uint sint IEEE endian IETF
 -->
<!--  LocalWords:  signedness endianness ASN BER encodings OIDs OID
 -->
<!--  LocalWords:  Implementers
 -->
